Services 
********



1.LoadBalancer --> External
2.NodePort --> External
3.Cluster Ip  -->Internal network --> It uses database(when some needs to store data they store in backend services ) --> private

pods can be of 2 types 

1. frontend pods (loadbalancer and nodepod ) To see the frotend page use the loadbalancer or nodepod 

eg:html ,css 
 
2. backend pods
	
------------------------------------------


1. Nodeport ---> To access a single pod it uses nodeport
  
	1. Port
	2. Targetport
	3. Type



---------------------------------------------


2. Loadbalancer --> when we are using multiple replicas we use loadbalancer 

eg: suppose i have 10 pods in each pods some service is running(sonarqube) -> for this we use single endpoint

	we have to write a service for pods pod1 --> label(app:myapp1) --matchlabels -->



-----------------------------------------------

3. clusterip -->   






-------------------------------------------



In Kubernetes, Services provide a stable network endpoint to access a group of pods. Since pods are ephemeral (they come and go), Services ensure consistent access to your app components like frontend, backend, or database.

ðŸ”§ Types of Kubernetes Services

Service Type	Description

ClusterIP	Default. Accessible only within the cluster. Used for internal communication between pods (e.g., frontend â†’ backend).

NodePort	Exposes the service on a static port on each Nodeâ€™s IP. Used for basic external access.

LoadBalancer	Integrates with cloud provider's external load balancer. Used for public-facing apps.

ExternalName	Maps the service to a DNS name outside the cluster.
Headless Service	No Cluster IP; used for direct pod discovery (e.g., StatefulSets, databases).

ðŸ“¦ Use Case: Frontend and Backend Pods
Letâ€™s say you have:

Frontend Pods running a React or Angular app

Backend Pods running a Node.js/Java/Python API

âœ… 1. Backend Service (ClusterIP)
You expose backend pods with a ClusterIP so only internal traffic (like frontend) can reach it:

yaml
Copy
Edit
apiVersion: v1
kind: Service
metadata:
  name: backend-service
spec:
  selector:
    app: backend
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
  type: ClusterIP
Pods with label app: backend will be targeted

Frontend can access it via http://backend-service:80

âœ… 2. Frontend Service (LoadBalancer or NodePort)
Frontend needs to be accessed by end users, so you expose it via LoadBalancer (in cloud) or NodePort (on-premise):

yaml
Copy
Edit
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
spec:
  selector:
    app: frontend
  ports:
    - protocol: TCP
      port: 80
      targetPort: 3000
  type: LoadBalancer
If you're on AWS, GCP, Azure â†’ this will provision a cloud load balancer

Users can open the app via http://<external-ip>:80

ðŸ” Communication Flow
bash
Copy
Edit
User's Browser --> LoadBalancer --> Frontend Pods
Frontend Pods   --> ClusterIP     --> Backend Pods